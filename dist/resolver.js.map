{"version":3,"sources":["../src/resolver.js"],"names":["createResolver","resFn","errFn","Promise","baseResolver","root","args","context","info","resolve","catch","e","Object","assign","error","then","parsedError","cResFn","cErrFn","childResFn","entry","r","childErrFn","err"],"mappings":";;;;;;;AAAA;;AACA;;AAGO,IAAMA,0CAAiB,SAAjBA,cAAiB,CAACC,KAAD,EAAQC,KAAR,EAAkB;AAC9C,MAAMC,UAAU,0BAAhB;AACA,MAAMC,eAAe,SAAfA,YAAe,CAACC,IAAD,EAA8C;AAAA,QAAvCC,IAAuC,uEAAhC,EAAgC;AAAA,QAA5BC,OAA4B,uEAAlB,EAAkB;AAAA,QAAdC,IAAc,uEAAP,EAAO;;AACjE;AACA,QAAI,CAAC,sBAAWP,KAAX,CAAL,EAAwB,OAAOE,QAAQM,OAAR,CAAgB,IAAhB,CAAP;AACxB,WAAO,qBAAUR,KAAV,EAAiBI,IAAjB,EAAuBC,IAAvB,EAA6BC,OAA7B,EAAsCC,IAAtC,EAA4CE,KAA5C,CAAkD,aAAK;AAC5D;AACA,UAAI,CAAC,sBAAWR,KAAX,CAAL,EAAwB,MAAMS,CAAN;AACxB;AACA,aAAO,qBAAUT,KAAV,EAAiBG,IAAjB,EAAuBC,IAAvB,EAA6BC,OAA7B,EAAsCK,OAAOC,MAAP,CAAc,EAACC,OAAOH,CAAR,EAAd,EAA0BH,IAA1B,CAAtC,EAAuEO,IAAvE,CAA4E,uBAAe;AAChG;AACA,cAAMC,eAAeL,CAArB;AACD,OAHM,EAGJ,uBAAe;AAChB;AACA,cAAMK,eAAeL,CAArB;AACD,OANM,CAAP;AAOD,KAXM,CAAP;AAYD,GAfD;;AAiBAP,eAAaJ,cAAb,GAA8B,UAACiB,MAAD,EAASC,MAAT,EAAoB;AAChD,QAAMf,UAAU,0BAAhB;;AAEA,QAAMgB,aAAa,SAAbA,UAAa,CAACd,IAAD,EAAOC,IAAP,EAAaC,OAAb,EAAsBC,IAAtB,EAA+B;AAChD;AACA,UAAMY,QAAQ,sBAAWnB,KAAX,IAAoB,qBAAUA,KAAV,EAAiBI,IAAjB,EAAuBC,IAAvB,EAA6BC,OAA7B,EAAsCC,IAAtC,CAApB,GAAkEL,QAAQM,OAAR,CAAgB,IAAhB,CAAhF;AACA,aAAOW,MAAML,IAAN,CAAW,aAAK;AACrB;AACA,YAAI,gCAAqBM,CAArB,CAAJ,EAA6B,OAAOA,CAAP;AAC7B;AACA,eAAO,sBAAWJ,MAAX,IAAqB,qBAAUA,MAAV,EAAkBZ,IAAlB,EAAwBC,IAAxB,EAA8BC,OAA9B,EAAuCC,IAAvC,CAArB,GAAoEL,QAAQM,OAAR,CAAgB,IAAhB,CAA3E;AACD,OALM,CAAP;AAMD,KATD;;AAWA,QAAMa,aAAa,SAAbA,UAAa,CAACjB,IAAD,EAAOC,IAAP,EAAaC,OAAb,EAAsBgB,GAAtB,EAA8B;AAC/C;AACA,UAAMH,QAAQ,sBAAWF,MAAX,IAAqB,qBAAUA,MAAV,EAAkBb,IAAlB,EAAwBC,IAAxB,EAA8BC,OAA9B,EAAuCgB,GAAvC,CAArB,GAAmEpB,QAAQM,OAAR,CAAgB,IAAhB,CAAjF;;AAEA,aAAOW,MAAML,IAAN,CAAW,aAAK;AACrB;AACA,YAAI,gCAAqBM,CAArB,CAAJ,EAA6B,MAAMA,CAAN;AAC7B;AACA,eAAO,sBAAWnB,KAAX,IAAoB,qBAAUA,KAAV,EAAiBG,IAAjB,EAAuBC,IAAvB,EAA6BC,OAA7B,EAAsCgB,GAAtC,EAA2CR,IAA3C,CAAgD,aAAK;AAC9E;AACA,gBAAMJ,KAAKY,GAAX;AACD,SAH0B,EAGxB,aAAK;AACN;AACA,gBAAMZ,KAAKY,GAAX;AACD,SAN0B,CAApB,GAMFpB,QAAQM,OAAR,CAAgB,IAAhB,CANL;AAOD,OAXM,CAAP;AAYD,KAhBD;;AAkBA;AACA,WAAOT,eAAemB,UAAf,EAA2BG,UAA3B,CAAP;AACD,GAlCD;;AAoCA,SAAOlB,YAAP;AACD,CAxDM","file":"resolver.js","sourcesContent":["import { getPromise } from './promise';\nimport { isFunction, Promisify, isNotNullOrUndefined } from './util';\n\n\nexport const createResolver = (resFn, errFn) => {\n  const Promise = getPromise();\n  const baseResolver = (root, args = {}, context = {}, info = {}) => {\n    // Return resolving promise with `null` if the resolver function param is not a function\n    if (!isFunction(resFn)) return Promise.resolve(null);\n    return Promisify(resFn)(root, args, context, info).catch(e => {\n      // On error, check if there is an error handler.  If not, throw the original error\n      if (!isFunction(errFn)) throw e;\n      // Call the error handler.\n      return Promisify(errFn)(root, args, context, Object.assign({error: e}, info)).then(parsedError => {\n        // If it resolves, throw the resolving value or the original error.\n        throw parsedError || e\n      }, parsedError => {\n        // If it rejects, throw the rejecting value or the original error\n        throw parsedError || e\n      });\n    });\n  };\n\n  baseResolver.createResolver = (cResFn, cErrFn) => {\n    const Promise = getPromise();\n\n    const childResFn = (root, args, context, info) => {\n      // Start with either the parent resolver function or a no-op (returns null)\n      const entry = isFunction(resFn) ? Promisify(resFn)(root, args, context, info) : Promise.resolve(null);\n      return entry.then(r => {\n        // If the parent returns a value, continue\n        if (isNotNullOrUndefined(r)) return r;\n        // Call the child resolver function or a no-op (returns null)\n        return isFunction(cResFn) ? Promisify(cResFn)(root, args, context, info) : Promise.resolve(null);\n      });\n    };\n\n    const childErrFn = (root, args, context, err) => {\n      // Start with either the child error handler or a no-op (returns null)\n      const entry = isFunction(cErrFn) ? Promisify(cErrFn)(root, args, context, err) : Promise.resolve(null);\n      \n      return entry.then(r => {\n        // If the child returns a value, throw it\n        if (isNotNullOrUndefined(r)) throw r;\n        // Call the parent error handler or a no-op (returns null)\n        return isFunction(errFn) ? Promisify(errFn)(root, args, context, err).then(e => {\n          // If it resolves, throw the resolving value or the original error\n          throw e || err;\n        }, e => {\n          // If it rejects, throw the rejecting value or the original error\n          throw e || err;\n        }) : Promise.resolve(null);\n      });\n    };\n    \n    // Create the child resolver and return it\n    return createResolver(childResFn, childErrFn);\n  }\n\n  return baseResolver;\n};\n"]}